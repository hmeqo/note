"""list  列表"""


'''
1.[1, '1']  列表，可变序列，有索引

下标索引: 取出索引对应的值，正数索引从0开始，向右。负数索引从-1开始，向左
    [1, 2, 3, '123']  # 列表
     0  1  2   3      # 正数索引
    -4 -3 -2  -1      # 负数索引
格式: [1, '1'][0]
      [1, '1'][-1]
切片:
默认从0开始，默认到末尾结束，默认步长是1，索引之间用冒号隔开
填两个索引时，指定开始和结束，不包含结束
填三个参数时，是定开始结束和步长。步长为正数从左到右，负数从右到左
格式: [1, '1'][0:1]
      [1, '1'][1:0:-1]
切片能用来获取元素也能用来添加修改删除元素。右侧值必须是可迭代对象，可迭代对象是字典时，只拿出键
指定索引也可以做到添加修改删除，但只能且必须替换掉一个元素，用新的元素覆盖，切片可以无损添加，删除元素时，只能用 del

也可以使用加号和乘号，加号将两个列表拼接，乘号，多个这样的列表拼接，这几个列表的值都一样，值的id都相同

第一个列表中的第二个列表称为二维列表
'''

print('1.')
print('——————————————————————————————————————————————————')

lst = [1, 2, 3, '123']
print('1.', lst[0])
print('2.', lst[-3])
print('3.', lst[1:3])
print('4.', lst[-1:1:-1])
print('5.', '原列表', lst)
lst[len(lst):] = ['a']
print('新列表', lst)
lst = [1, 2, 3, '123']
print('6.', '原列表', lst)
lst[len(lst):] = ['bc', 'UTF-8']
print('新列表', lst)
lst = [1, 2, 3, '123']
print('7.', '原列表', lst)
lst[1] = 'abc'
print('新列表', lst)
lst = [1, 2, 3, '123']
print('8.', '原列表', lst)
lst[1:3] = ['abc']
print('新列表', lst)
lst = [1, 2, 3, '123']
print('9.', '原列表', lst)
lst[1:3] = {'abc': '我呢？', 'nn': '？？？'}
print('新列表', lst)
lst2 = ['拼接']
print('10.', '将 lst 与 lst2 拼接，原列表', lst, lst2)
print('拼接后', lst + lst2, '并没有修改原列表')
print('原列表', lst, lst2)
print('11.', lst2 * 3, '并没有修改原列表')
print('原列表', lst2)
lst3 = [[]] * 3
print('12.', lst3)
print(lst3[0] is lst3[1])
lst3[0].append(1)
print(lst3)

print('——————————————————————————————————————————————————')
print('\n')


'''
2.append() extend() insert()

增加列表元素
append()  在末尾添加一个元素。整个添加
extend()  在末尾添加多个元素。参数必须是一个可迭代对象
insert()  插入一个元素。参数有两个，第一个是索引，在哪个位置添加，第二个是参数
'''

print('2.')
print('——————————————————————————————————————————————————')

lst = [1, 2, 3, '123']
print('1.', '原列表', lst)
lst.append('哈哈')
print('新列表', lst)
lst = [1, 2, 3, '123']
print('2.', '原列表', lst)
lst.extend('哈哈')
print('新列表', lst)
lst = [1, 2, 3, '123']
print('3.', '原列表', lst)
lst.extend(['哈哈', 88])
print('新列表', lst)
lst = [1, 2, 3, '123']
print('4.', '原列表', lst)
lst.insert(len(lst), ['哈哈', 88])
print('新列表', lst)

print('——————————————————————————————————————————————————')
print('\n')


'''
3.remove() pop() clear()

删除列表元素
remove()  删除一个元素，如果列表中存在多个匹配的元素，只会删除第一个，元素不存在会报错
pop()  弹出索引对应的元素，弹出的元素是可以被获取的
clear()  清空列表
也可以用 del 语句删除，直接填写列表是删除这个列表，列表加下标索引是删除这个索引位置上的元素
'''

print('3.')
print('——————————————————————————————————————————————————')

lst = [1, 2, 3, '123']
print('1.', '原列表', lst)
lst.remove('123')
print('新列表', lst)
lst = [1, 2, 3, '123']
print('2.', '原列表', lst)
a = lst.pop(2)
print('新列表', lst, '弹出的元素', a)
lst = [1, 2, 3, '123']
print('3.', '原列表', lst)
lst.clear()
print('新列表', lst)
lst = [1, 2, 3, '123']
print('4.', '原列表', lst)
del lst
print('新列表', '...列表被删除了，没有列表')
lst = [1, 2, 3, '123']
print('5.', '原列表', lst)
del lst[2]
print('新列表', lst)

print('——————————————————————————————————————————————————')
print('\n')


'''
4.sort() reverse() sorted()

列表元素的排序
sort()  从小到大排序，参数 reverse=False，设置为 True 时，倒着排序
reverse()  反转列表
sorted()  函数，对列表临时排序

注意：列表中不能存在不同的数据类型，要比较的值必须是同一数据类型
本质上使用的是比较运算符比较的值
'''

print('4.')
print('——————————————————————————————————————————————————')

lst = [3, 12, 6, 1, 72, 5, 8, 2, 0]
print('1.', '原列表', lst)
lst.sort()
print('新列表', lst)
lst = [3, 12, 6, 1, 72, 5, 8, 2, 0]
print('2.', '原列表', lst)
lst.sort(reverse=True)
print('新列表', lst)
print('3.', '原列表', lst)
lst.reverse()
print('新列表', lst)
print('4.', '原列表', lst)
print('新列表', sorted(lst))
print('并没有改变原列表', sorted(lst))
lst = [[1, '2'], [2, 2]]
lst.sort()
print(lst)

print('——————————————————————————————————————————————————')
print('\n')


'''
5.count() index()

查找列表元素
都支持传入第二第三个参数，start 和 end，开始和结束，指定查找范围
count()  该元素在列表中出现了几次
index()  查找该元素在列表中的索引。返回第一次查找到的元素的索引
'''

print('5.')
print('——————————————————————————————————————————————————')

lst = [3, 1, 333, 3, 4, 4, 3, 5, 3]
print('1.', '3 在列表中有几个', lst.count(3))
print('2.', '333 在列表中的索引', lst.index(333))
print('3.', '3 在列表中的索引', lst.index(3))
print('4.', '3 在某段列表中的索引', lst.index(3, 2, 4))

print('——————————————————————————————————————————————————')
print('\n')


'''
6.copy()

复制列表
属于浅拷贝，里面的相同的元素指向同一个id
切片也能做到拷贝，也属于浅拷贝
（深拷贝请访问模块 copy 相关内容，这里不做介绍）
'''

print('6.')
print('——————————————————————————————————————————————————')

lst = [3, 1, 333, 3, 4, 4, 3, 5, 3]
print('1.', '原列表', lst)
lst_copy1 = lst.copy()
print('拷贝的列表', lst_copy1)
print('对比两个列表的第一个元素的id', id(lst[0]), '\n', id(lst_copy1[0]))
print('2.', '原列表', lst)
lst_copy2 = lst[:]
print('拷贝的列表', lst_copy2)
print('对比两个列表的id', id(lst[0]), '\n', id(lst_copy2[0]))

print('——————————————————————————————————————————————————')
print('\n')


'''
7.[for in]

列表推导式，列表生成式，列表解析
格式：[i for i in range(10)]

据说使用的是C语言，效率更高
列表推导式可以使用 if 判断，支持嵌套
'''

print('7.')
print('——————————————————————————————————————————————————')

lst = [i for i in range(10)]
print('1.', lst)
lst = [i * 2 for i in range(10)]
print('2.', lst)
lst = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
print('3.', [i[1] for i in lst])
print('4.', [lst[i][i] for i in range(len(lst))])
print('5.', [lst[i][len(lst) - 1 - i] for i in range(len(lst))])
lst = [[0] * 3 for i in range(3)]
print('6.', lst)
print('7.', [i for i in range(10) if not i % 2])
print('8.', [[g, i] for g in range(4) for i in range(4)])
print('9.', [[g, i] for g in range(10) if not g % 2
             for i in range(10) if not i % 3])

print('——————————————————————————————————————————————————')
print('\n')
