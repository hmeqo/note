"""正则语法规则"""
import re


r'''
1.正则是新的字符串规则，所以需要提交原始字符串，在字符串前加上 r
例如用 r'hello' 匹配 'hello \n world'

元字符: . \ [] {} () | ^ $ * + ?

正则中空格被当做一个元素，在字符类（括号吧）中用于分组
想使用空格美化代码怎么办，在参数 flags 中填入 re.VERBOSE
就可以换行添加空格了，但对字符类不起作用，字符类中还是用于分组
这时候想使用空格作为元素怎么办，使用转义字符转义
'''

print('1.')
print('——————————————————————————————————————————————————')

print('1.')

print('——————————————————————————————————————————————————')
print('\n')


'''
2.表达式中的 . 号，是一个通配符，可以匹配任何一个字符（除了换行符）

通过设置 re.DOTALL 可以使它匹配任何字符
'''

print('2.')
print('——————————————————————————————————————————————————')

print('1.')

print('——————————————————————————————————————————————————')
print('\n')


r'''
3.表达式中的反斜杠 \，和非原始字符串中的反斜杠一样具特殊含义

给普通字符特殊含义，消除元字符的特殊含义
使用方法:
    \1  反斜杠加数字
        两位数及以内的序号 0-99，匹配左数第几组表达式得到的结果
            例子:
                r'(abc)', 'abcabc'  匹配 abc
                r'([a-z]{3})\1', 'abcabc'  匹配 abcabc
                r'([a-z]{3})\1', 'abcaac'  没有匹配的内容
        以 0 开头或三位数的序号，匹配对应的八进制的 ASCII 编码的字符
    \.  消除 . 通配符的特殊含义，匹配 . 这个字符
    \A  匹配开头位置，相当于 ^
    \Z  匹配结束位置，相当于 $
    \b  表示单词与非单词的边界， 非单词与单词的边界
        \b, \B是单词边界, 不匹配任何实际字符, 所以是看不到的; \B是\b的非(补)
        文中单词表示字母数字下划线
        例子:
            r'abc\b', 'abcdefg'  匹配 abc
            r'abc\b', 'abc_defg'  没有匹配的内容
    \B  表示单词与单词的边界，非单词与非单词的边界
    \d  匹配 Unicode 定义的十进制数字的字符，[0-9]
        如果开启了 re.ASCII 标志，匹配 ASCII 定义的十进制字符，[0-9]
    \D  匹配非十进制数字的字符
        如果开启了 re.ASCII 标志，相当于 [^0-9]
    \s  匹配 Unicode 定义的空白字符，[\t\n\r\f\v]
        如果开启了 re.ASCII 标志，匹配 [\t\n\r\f\v]
    \S  匹配非空白字符
        如果开启了 re.ASCII 标志，匹配 [^ \t\n\r\f\v]
    \w  匹配 Unicode 定义的单词字符，几乎所有语言的单词字符，数字下划线
        如果开启了 re.ASCII 标志，匹配 [a-zA-Z0-9]
    \W  匹配非单词字符
        如果开启了 re.ASCII 标志，匹配 [^a-z^A-Z^0-9]
    支持大部分 Python 中的转义字符:
        [\a \b \t \n \r \f \v \u \U \x \\]
        \b 一般匹配单词边界，只在字符类中表示退格
        \u 和 \U 只在 Unicode 模式下被识别
'''

print('3.')
print('——————————————————————————————————————————————————')

print('1.', re.search(r'([a-z]{3})\1', 'abcabc'))
print('2.', re.search(r'([a-z]{3})\1', 'abcaac'))
print('3.', re.search(r'abc\b', "abc#_defg"))
print('4.', re.search(r'abc\B', "abc#_defg"))

print('——————————————————————————————————————————————————')
print('\n')


r'''
4.[] {} ()

表达式中的括号
[]  指定匹配内容的范围:
    被包围的字符是非原始字符
    被包围的元字符失去意义，变成正常字符
    反斜杠是非正则的反斜杠
    在中括号中脱字符(^)表示除了后面的表达式以外的
    空格用于分组，类似小括号
    使用方法:
        [aeiou]  匹配其中任意一个字符
        [a-z]  匹配从 a 到 z 的任意一个字符
        [0-9]  匹配从 0 到 9 的任意一个字符
        [\n]  匹配换行符 \n
        [^a]  匹配除了 a 的字符
        [^a-z]  匹配除了 a 到 z 的字符
{}  匹配前一个字符或整体的次数:
    使用方法:
        ab{4}c  重复匹配 4 次（abbbbc）
        ab{4,10}c  重复匹配 4 到 10 次
()  将其中内容作为一个整体:
    使用方法：
        ([01]\.\d){3}  作为一个整体重复匹配三次
'''

print('4.')
print('——————————————————————————————————————————————————')

print('1.', re.search(
    r'(([01]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])\.){3}'
    + r'([01]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])',
    '192.168.1.1'
))
print('2.', re.findall(r'[^a]', 'abaab'))

print('——————————————————————————————————————————————————')
print('\n')


'''
5.| ^ $

|  或者
    使用方法:
        abc|b{3}  匹配 abc 或者 bbb
^  匹配输入字符串的开始位置，从开头开始匹配。右侧表达式结果位置在行首
    如果设置了 re.MULTILINE，也匹配换行符之后的位置
    使用方法:
        ^abc  开头匹配 abc
$  匹配输入字符串的结束位置，从末尾开始匹配。左侧表达式结果位置在行尾
    如果设置了 re.MULTILINE，也匹配换行符之前的位置
    使用方法:
        abc$  末尾匹配 abc
'''

print('5.')
print('——————————————————————————————————————————————————')

print('1.')

print('——————————————————————————————————————————————————')
print('\n')


'''
6.* + ?

匹配次数，相当于 {} 的简写
*  匹配前面的子表达式 0 次或多次，相当于 {0,}，尽可能多的匹配
    例子:
        r'a*', 'aaaa'  匹配 aaaa
        r'a*', 'aabb'  匹配 aa
+  匹配前面的子表达式 1 次或多次，相当于 {1,}，尽可能多的匹配
    例子:
        r'a+', 'aaaa'  匹配 aaaa
        r'a+', 'aabb'  匹配 aa
?  匹配前面的子表达式 0 次或 1 次，相当于 {0,1}
    可以跟在 * + ? {} 后面（*? +? ?? {}?），表示非贪婪模式
    例子:
        r'<.+?>', '<aabb>aabb'  匹配 <aabb>
'''

print('6.')
print('——————————————————————————————————————————————————')

print('1.')

print('——————————————————————————————————————————————————')
print('\n')


'''
7.(?#) (?:) (?=) (?!) (?<=) (?<!) (?P<>) (?P=)

拓展语法
# (?) 小括号内 ? 号开头表示正则表达式的拓展语法
(?#)  注释，括号内的内容被忽视
(?:)  该子组匹配的字符串无法从后边捕获
(?=)  向前肯定断言，当左侧紧跟着此表达式则匹配成功
    例:
        r'b(?=c)', 'abcd'  如果 b 后紧跟着 c 则 b 匹配成功
(?!)  向前否定断言，当左侧不紧跟着此表达式则匹配成功
(?<=)  向后肯定断言，当右侧紧跟着此表达式则匹配成功
(?<!)  向后肯定断言，当右侧不紧跟着此表达式则匹配成功
(?P<>)  给匹配到的值命名
    例:
        r'(?P<name>\d+)', '1234'  给匹配到的 1234 起名 name
(?P=)  使用命名调用值
    例:
        r'(?P<name>\d)(?P=name)', '11'  前者匹配了 1 ，后者再匹配一次 1
'''

print('7.')
print('——————————————————————————————————————————————————')

print('1.')

print('——————————————————————————————————————————————————')
print('\n')
